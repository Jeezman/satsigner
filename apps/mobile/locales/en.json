{
  "en": {
    "satsigner": {
      "name": "SatSigner"
    },
    "common": {
      "cancel": "Cancel",
      "valid": "Valid",
      "invalid": "Invalid",
      "optional": "Optional",
      "select": "Select",
      "selectAll": "Select All",
      "selected": "Selected",
      "deselectAll": "Deselect All",
      "next": "Next",
      "confirm": "Confirm",
      "close": "Close",
      "acknowledge": "Acknowledge",
      "warning": "Warning",
      "of": "Of",
      "to": "To",
      "more": "More",
      "less": "Less",
      "total": "Total",
      "date": "Date",
      "amount": "Amount",
      "save": "Save",
      "from": "From",
      "memo": "Memo",
      "clear": "Clear",
      "goBack": "Go back",
      "version": "Version",
      "address": "Address",
      "transaction": "Transaction",
      "bytes": "Bytes",
      "tags": "Tags",
      "label": "Label",
      "block": "Block",
      "outputIndex": "Output index",
      "value": "Value",
      "addTag": "Add tag",
      "createTag": "Create tag"
    },
    "time": {
      "lessThanAMinute": "Less than a minute"
    },
    "bitcoin": {
      "word": "Word",
      "words": "Words",
      "checksum": "Checksum",
      "fingerprint": "Fingerprint",
      "passphrase": "Passphrase",
      "script": "Script",
      "notYourKeys": "Not your keys",
      "notYourCoins": "Not your coins",
      "sats": "Sats",
      "memo": "Memo",
      "confirmations": {
        "unconfirmed": "Unconfirmed",
        "oneBlock": "Block deep",
        "manyBlocks": "Blocks deep"
      }
    },
    "auth": {
      "setPin": ["Set pin number to", "enter the app"],
      "reenterPin": ["Re-enter your", "pin number"],
      "confirm": "Confirm pin number",
      "set": "Set pin number",
      "setLater": "Set pin later",
      "pinsMatch": "Pin number match",
      "pinsDontMatch": "No pin number match",
      "unlock": "Unlock sat signer",
      "tryLeft": "Try left",
      "triesLeft": "Tries left"
    },
    "settings": {
      "title": "Config",
      "bitcoinNetwork": {
        "title": "Network",
        "description": "Connect to a node to communicate with the bitcoin main network, testnet or signet",
        "backend": "Backend",
        "network": "Network",
        "url": "Url",
        "retries": "Retries",
        "timeout": "Timeout",
        "stopGap": "Stop Gap"
      },
      "appSecurity": {
        "title": "App Security",
        "description": "Change app wide security settings to protect access in case of a compromised device",
        "maxPinTries": "Maximum pin tries",
        "backgroundLockTime": "Background lock time"
      },
      "about": {
        "title": "About",
        "description": "App version and other versioning information"
      },
      "developer": {
        "title": "Developer",
        "description": "Available in dev mode only. Useful tools for developers for faster development"
      },
      "features": {
        "title": "Features",
        "description": "Reveal more or less information about the app and the bitcoin protocol.",
        "featurePage": {
          "title": "Features",
          "transactionChart": {
            "title": "Transaction Chart",
            "description": "Control the visible layers and navigation of the transaction history chart"
          },
          "currencyFormatting": {
            "title": "Currency Formatting",
            "description": "Currency display and formatting"
          },
          "chartSettingsPage": {
            "title": "Chart Settings",
            "layersTitle": "Layers",
            "layersShowLabels": "Show Labels",
            "layersShowAmounts": "Show Amounts",
            "layersShowTransactionInfo": "Show Transaction Info",
            "layersShowOutputFields": "Show Output Fields",
            "navigationTitle": "Navigation",
            "navigationLockZoomXAxis": "Lock Zoom To X-Axis"
          }
        }
      }
    },
    "accountList": {
      "noKeysYet": "No keys yet",
      "totalTransactions": ["Total", "Transactions"],
      "childAccounts": ["Child", "Accounts"],
      "spendableOutputs": ["Spendable", "Outputs"],
      "satsInMempool": ["Sats in", "Mempool"]
    },
    "account": {
      "signAndSend": "Sign & Send",
      "newInvoice": "New Invoice",
      "parentAccountActivity": "Parent Account Activity",
      "noMemo": "No memo",
      "noLabel": "No label",
      "noTags": "No tags"
    },
    "signAndSend": {
      "selectSpendableOutputs": "Select spendable outputs",
      "addAsInputToMessage": "Add as input to message",
      "customAmount": "Custom amount",
      "selectAll": "Select all",
      "setMessageFee": "Set message fee",
      "addInput": "Add input",
      "addOutput": "Add output",
      "addRecipientOutputs": "Add recipient outputs",
      "deselectAll": "Deselect all"
    },
    "ioPreview": {
      "typeMemo": "Type memo",
      "addInput": "Add input",
      "addOutput": "Add output",
      "setMessageFee": "Set message fee"
    },
    "feeSelection": {
      "previewTxMessage": "Preview tx message"
    },
    "previewMessage": {
      "signTxMessage": "Sign tx message"
    },
    "signMessage": {
      "broadcastTxMessage": "Broadcast tx message"
    },
    "messageConfirmation": {
      "messageBroadcasted": "Message broadcasted",
      "messageId": "Message id",
      "copyTxMessageId": "Copy tx message id",
      "trackOnChain": "Track on chain",
      "backToAccountHome": "Back to account home"
    },
    "camera": {
      "scanText": "Scan any Bitcoin or Lightning related QR code.",
      "permissions": "Enable camera access in your phone's settings to scan a QR code."
    },
    "newInvoice": {
      "invoice": "Invoice",
      "path": "Path",
      "address": "Address",
      "customAmount": "Custom Amount",
      "memo": "Memo",
      "generateAnotherInvoice": "Generate another invoice"
    },
    "addMasterKey": {
      "title": "Add Master Key",
      "masterKeyName": "Master Key Name",
      "hasAccountWithName": "Account with that name already exists",
      "walletSyncFailed": "Failed to sync wallet. Make sure you have internet connection.",
      "loadSampleSignetWallet": "Load sample Signet Wallet",
      "importWatchOnly": "Import Watch-Only",
      "importWIF": "Import WIF (single key)",
      "generateNewSeed": {
        "title": "Generate New Secret Seed",
        "action": "Confirm Seed"
      },
      "confirmSeed": {
        "incorrectWordModal": {
          "warning": "Selected word doesn't match the original seed",
          "action": "Review and try again"
        },
        "warningModal": {
          "warning": "Keep this information secret and backed up.",
          "disclaimer1": "Anyone with this information can move the sats to another account.",
          "disclaimer2": "Consider an air-gapped hardware device for generating keys for significant amounts.",
          "disclaimer3": "Losing this information will lose the funds."
        }
      },
      "importExistingSeed": {
        "title": "Import Existing Seed",
        "action": "Save Secret Seed",
        "accountAdded": "Parent account has been added",
        "accountAddedModal": {
          "derivationPath": "Derivation path",
          "utxos": "Found UTXOs",
          "sats": "Total spendable sats"
        },
        "noMatchingWords": "No Matching Words"
      },
      "accountOptions": {
        "policyType": "Policy Type",
        "scriptVersion": "Script Version",
        "scriptVersions": {
          "names": {
            "p2pkh": "Legacy",
            "p2sh-p2wpkh": "Nested Segwit",
            "p2wpkh": "Native Segwit",
            "p2tr": "Taproot"
          },
          "descriptions": {
            "p2pkh": [
              "Legacy",
              "which locks bitcoin to the hash of a public key."
            ],
            "p2sh-p2wpkh": [
              "Nested Segwit",
              "which locks bitcoin to a SegWit witness program wrapped inside a P2SH address. This allows SegWit compatibility with wallets or services that do not fully support SegWit."
            ],
            "p2wpkh": [
              "Native Segwit",
              "which locks bitcoin to a SegWit witness program. It offers reduced transaction fees and improved malleability resistance."
            ],
            "p2tr": [
              "Taproot",
              "which locks bitcoin to a Schnorr public key or a Merkle root of multiple conditions. It enhances privacy and efficiency by combining spending conditions into a single structure."
            ]
          },
          "links": {
            "name": {
              "p2pkh": "ScriptPubKey",
              "p2sh-p2wpkh": "ScriptPubKey",
              "p2wpkh": "ScriptPubKey",
              "p2tr": "ScriptPubKey"
            },
            "url": {
              "p2pkh": "https://river.com/learn/terms/s/scriptpubkey/",
              "p2sh-p2wpkh": "https://river.com/learn/terms/s/scriptpubkey/",
              "p2wpkh": "https://river.com/learn/terms/s/scriptpubkey/",
              "p2tr": "https://river.com/learn/terms/s/scriptpubkey/"
            }
          }
        },
        "mnemonic": "Mnemonic Seed Words (BIP39)",
        "mnemonics": {
          "24": "24 words generated from 256 bits of entropy.",
          "21": "21 words generated from 224 bits of entropy.  For potentially increased computational security, consider using 24 words for new accounts.",
          "18": "18 words generated from 192 bits of entropy.  For potentially increased computational security, consider using 24 words for new accounts.",
          "15": "15 words generated from 160 bits of entropy.  For potentially increased computational security, consider using 24 words for new accounts.",
          "12": "12 words generated from 128 bits of entropy.  For potentially increased computational security, consider using 24 words for new accounts."
        },
        "generateNewSeed": "Generate New Seed",
        "importSeed": "Import Seed",
        "policyTypes": {
          "singleSignature": "Single Signature",
          "singleSignatureDescription": "To solve this script, the owner of the hashed public key above needs to provide the original public key, along with a valid signature for it.",
          "multiSignature": "Multi Signature",
          "multiSignatureDescription": "Lorem ipsum"
        }
      }
    },
    "utxoDetails": {
      "title": "UTXO Details",
      "label": "UTXO Label",
      "labelEdit": "Edit UTXO label"
    },
    "txDetails": {
      "title": "TX Details",
      "block": "In block",
      "hash": "Transaction hash",
      "size": "Raw size",
      "weight": "Weight",
      "vsize": "Virtual Size",
      "fee": "Fee",
      "feeBytes": "Fee sat/b",
      "feeVBytes": "Fee sat/vb",
      "details": "Transaction details",
      "decoded": "Transaction decoded",
      "version": "Version",
      "inputsCount": "Number of inputs",
      "outputsCount": "Number of outputs",
      "input": "Input",
      "output": "Output",
      "inputPrevTx": "Previous TX Output hash",
      "inputPrevOut": "Output index in transaction",
      "inputSequence": "Sequence",
      "label": "Transaction label",
      "labelEdit": "Edit TX label"
    },
    "txDecoded": {
      "description": {
        "version": "This is a 4-byte little-endian integer, representing the transaction version",
        "marker": "This is an 1-byte marker (required to be '00') that serves as an indicator that the given transaction incorporates Segregated Witness (segwit) data.",
        "flag": "This is an 1-byte flag that follows the marker in transactions with witness data. It must be non-zero. It can be interpreted as a bitvector, with the unused bits available for future extensibility for other types of witness data.",
        "txInVarInt": "This is a variable integer (VarInt) that denotes the number of subsequent transaction inputs.",
        "txInHash": "This is the hash of the transaction input. Note that the transaction hash here is in big-endian format, whereas in other places it is typically represented in little-endian format.",
        "txInIndex": "This is a 4-byte little-endian integer which represents the index of the specific output in the previous transaction.",
        "txInScriptVarInt": "This is a variable integer (VarInt) that denotes the length of the subsequent unlocking script.",
        "txInScript": "This is the unlocking script (scriptSig), providing proof of ownership of the bitcoins being spent.",
        "txInSequence": "This is a 4-byte little-endian number that specifies the relative locktime of the transaction input.",
        "txOutVarInt": "This is a variable integer (VarInt) that denotes the number of subsequent transaction outputs.",
        "txOutValue": "This is an 8-byte little-endian number that represents the amount of bitcoin to be sent in satoshis.",
        "txOutScriptVarInt": "This is a variable integer (VarInt) that denotes the length (in bytes) of the subsequent locking script.",
        "txOutScript": "This is the locking script (scriptPubKey), specifying the conditions under which the output can be spent.",
        "witnessVarInt": "This is a variable integer (VarInt) that indicates the number of witness items for the transaction input. Note that each segwit input has its own witnessVarInt. The order of the witness items is the same as the order of the transaction inputs.",
        "witnessItemsVarInt": "This is a variable integer (VarInt) that denotes the length (in bytes) of the subsequent witness item.",
        "witnessItem": "This is a witness item.",
        "witnessItemEmpty": "This witness item is empty.",
        "witnessItemPubkey": "This witness item is a public key.",
        "witnessItemSignature": "This witness item is a signature.",
        "witnessItemScript": "This witness item is a script.",
        "locktime": "This is a 4-byte little-endian number that specifies the absolute locktime of the transaction.",
        "txOutScriptStandard": "This scriptPubkey is a standard type and can be encoded as the following address: %s",
        "txOutScriptNonStandard": "This scriptPubKey is non-standard and therefore cannot be encoded as an address."
      },
      "label": {
        "version": "version",
        "marker": "marker",
        "flag": "flag",
        "txInVarInt": "Input count",
        "txInHash": "Input previous tx hash (input %d)",
        "txInIndex": "Input previous output index (input %d)",
        "txInScriptVarInt": "Input script length (input %d)",
        "txInScript": "Input signature script (input %d)",
        "txInSequence": "Input sequence (input %d)",
        "txOutVarInt": "Output count",
        "txOutValue": "Output value (output %d)",
        "txOutScriptVarInt": "Output script length (output %d)",
        "txOutScript": "Output unlocking script (output %d)",
        "witnessVarInt": "Witness count",
        "witnessItemsVarInt": "Witness item length (input %d witness %d)",
        "witnessItem": "Witness item (input %d witness %d)",
        "witnessItemEmpty": "Witness item (input %d witness %d)",
        "witnessItemPubkey": "Witness item (input %d witness %d)",
        "witnessItemSignature": "Witness item (input %d witness %d)",
        "witnessItemScript": "Witness item (input %d witness %d)",
        "locktime": "LockTime",
        "txOutScriptStandard": "Output unlocking script (output %d)",
        "txOutScriptNonStandard": "Output unlocking script (output %d)"
      }
    },
    "opcode": {
      "DATA": "Data which can be hash, pubkey, address, signature, etc.",
      "OP_FALSE": "An empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.)",
      "OP_PUSH": "The next <em>opcode</em> bytes is data to be pushed onto the stack",
      "OP_PUSHDATA1": "The next byte contains the number of bytes to be pushed onto the stack.",
      "OP_PUSHDATA2": "The next two bytes contain the number of bytes to be pushed onto the stack in little endian order.",
      "OP_PUSHDATA4": "The next four bytes contain the number of bytes to be pushed onto the stack in little endian order.",
      "OP_1NEGATE": "The number -1 is pushed onto the stack.",
      "OP_RESERVED": "<strong>Transaction is invalid</strong> unless occuring in an unexecuted OP_IF branch",
      "OP_TRUE": "The number 1 is pushed onto the stack.",
      "OP_N": "The number in the word name (1-16) is pushed onto the stack.",
      "OP_NOP": "Does nothing.",
      "OP_VER": "<strong>Transaction is invalid</strong> unless occuring in an unexecuted OP_IF branch.",
      "OP_IF": "If the top stack value is not False, the statements are executed. The top stack value is removed.",
      "OP_NOTIF": "If the top stack value is False, the statements are executed. The top stack value is removed.",
      "OP_VERIF": "<strong>Transaction is invalid even when occuring in an unexecuted OP_IF branch</strong>.",
      "OP_VERNOTIF": "<strong>Transaction is invalid even when occuring in an unexecuted OP_IF branch</strong>.",
      "OP_ELSE": "If the preceding OP_IF or OP_NOTIF or OP_ELSE was not executed then these statements are and if the preceding OP_IF or OP_NOTIF or OP_ELSE was executed then these statements are not.",
      "OP_ENDIF": "Ends an if/else block. All blocks must end, or the transaction is <strong>invalid</strong>. An OP_ENDIF without OP_IF earlier is also <strong>invalid</strong>.",
      "OP_VERIFY": "<strong>Marks transaction as invalid</strong> if top stack value is not true. The top stack value is removed.",
      "OP_RETURN": "<strong>Marks transaction as invalid</strong>. Since bitcoin 0.9, a standard way of attaching extra data to transactions is to add a zero-value output with a scriptPubKey consisting of OP_RETURN followed by data. Such outputs are provably unspendable and specially discarded from storage in the UTXO set, reducing their cost to the network. Since 0.12, standard relay rules allow a single output with OP_RETURN, that contains any sequence of push statements (or OP_RESERVED[1]) after the OP_RETURN provided the total scriptPubKey length is at most 83 bytes.",
      "OP_TOALTSTACK": "Puts the input onto the top of the alt stack. Removes it from the main stack.",
      "OP_FROMALTSTACK": "Puts the input onto the top of the main stack. Removes it from the alt stack.",
      "OP_2DROP": "Removes the top two stack items.",
      "OP_2DUP": "Duplicates the top two stack items.",
      "OP_3DUP": "Duplicates the top three stack items.",
      "OP_2OVER": "Copies the pair of items two spaces back in the stack to the front.",
      "OP_2ROT": "The fifth and sixth items back are moved to the top of the stack.",
      "OP_2SWAP": "Swaps the top two pairs of items.",
      "OP_IFDUP": "If the top stack value is not 0, duplicate it.",
      "OP_DEPTH": "Puts the number of stack items onto the stack.",
      "OP_DROP": "Removes the top stack item.",
      "OP_DUP": "Duplicates the top stack item.",
      "OP_NIP": "Removes the second-to-top stack item.",
      "OP_OVER": "Copies the second-to-top stack item to the top.",
      "OP_PICK": "The item <em>n</em> back in the stack is copied to the top.",
      "OP_ROLL": "The item <em>n</em> back in the stack is moved to the top.",
      "OP_ROT": "The 3rd item down the stack is moved to the top.",
      "OP_SWAP": "The top two items on the stack are swapped.",
      "OP_TUCK": "The item at the top of the stack is copied and inserted before the second-to-top item.",
      "OP_CAT": "Concatenates two strings. <em>disabled</em>.",
      "OP_SUBSTR": "Returns a section of a string. <em>disabled</em>.",
      "OP_LEFT": "Keeps only characters left of the specified point in a string. <em>disabled</em>.",
      "OP_RIGHT": "Keeps only characters right of the specified point in a string. <em>disabled</em>.",
      "OP_SIZE": "Pushes the string length of the top element of the stack (without popping it).",
      "OP_INVERT": "Flips all of the bits in the input. <em>disabled</em>.",
      "OP_AND": "Boolean and between each bit in the inputs. <em>disabled</em>.",
      "OP_OR": "Boolean or between each bit in the inputs. <em>disabled</em>.",
      "OP_XOR": "Boolean exclusive or between each bit in the inputs. <em>disabled</em>.",
      "OP_EQUAL": "Returns 1 if the inputs are exactly equal, 0 otherwise.",
      "OP_EQUALVERIFY": "Same as OP_EQUAL, but runs OP_VERIFY afterward.",
      "OP_RESERVED1": "<strong>Transaction is invalid</strong> unless occuring in an unexecuted OP_IF branch.",
      "OP_RESERVED2": "<strong>Transaction is invalid</strong> unless occuring in an unexecuted OP_IF branch.",
      "OP_1ADD": "1 is added to the input.",
      "OP_1SUB": "1 is subtracted from the input.",
      "OP_2MUL": "The input is multiplied by 2. <em>disabled</em>.",
      "OP_2DIV": "The input is divided by 2. <em>disabled</em>.",
      "OP_NEGATE": "The sign of the input is flipped.",
      "OP_ABS": "The input is made positive.",
      "OP_NOT": "If the input is 0 or 1, it is flipped. Otherwise the output will be 0.",
      "OP_0NOTEQUAL": "Returns 0 if the input is 0. 1 otherwise.",
      "OP_ADD": "a is added to b.",
      "OP_SUB": "b is subtracted from a.",
      "OP_MUL": "a is multiplied by b. <em>disabled</em>.",
      "OP_DIV": "a is divided by b. <em>disabled</em>.",
      "OP_MOD": "Returns the remainder after dividing a by b. <em>disabled</em>.",
      "OP_LSHIFT": "Shifts a left b bits, preserving sign. <em>disabled</em>.",
      "OP_RSHIFT": "Shifts a right b bits, preserving sign. <em>disabled</em>.",
      "OP_BOOLAND": "If both a and b are not 0, the output is 1. Otherwise 0.",
      "OP_BOOLOR": "If a or b is not 0, the output is 1. Otherwise 0.",
      "OP_NUMEQUAL": "Returns 1 if the numbers are equal, 0 otherwise.",
      "OP_NUMEQUALVERIFY": "Same as OP_NUMEQUAL, but runs OP_VERIFY afterward.",
      "OP_NUMNOTEQUAL": "Returns 1 if the numbers are not equal, 0 otherwise.",
      "OP_LESSTHAN": "Returns 1 if a is less than b, 0 otherwise.",
      "OP_GREATERTHAN": "Returns 1 if a is greater than b, 0 otherwise.",
      "OP_LESSTHANOREQUAL": "Returns 1 if a is less than or equal to b, 0 otherwise.",
      "OP_GREATERTHANOREQUAL": "Returns 1 if a is greater than or equal to b, 0 otherwise.",
      "OP_MIN": "Returns the smaller of a and b.",
      "OP_MAX": "Returns the larger of a and b.",
      "OP_WITHIN": "Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.",
      "OP_RIPEMD160": "The input is hashed using RIPEMD-160.",
      "OP_SHA1": "The input is hashed using SHA-1.",
      "OP_SHA256": "The input is hashed using SHA-256.",
      "OP_HASH160": "The input is hashed twice: first with SHA-256 and then with RIPEMD-160.",
      "OP_HASH256": "The input is hashed two times with SHA-256.",
      "OP_CODESEPARATOR": "All of the signature checking words will only match signatures to the data after the most recently-executed OP_CODESEPARATOR.",
      "OP_CHECKSIG": "The entire transaction's outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end) are hashed. The signature used by OP_CHECKSIG must be a valid signature for this hash and public key. If it is, 1 is returned, 0 otherwise.",
      "OP_CHECKSIGVERIFY": "Same as OP_CHECKSIG, but OP_VERIFY is executed afterward.",
      "OP_CHECKMULTISIG": "Compares the first signature against each public key until it finds an ECDSA match. Starting with the subsequent public key, it compares the second signature against each remaining public key until it finds an ECDSA match. The process is repeated until all signatures have been checked or not enough public keys remain to produce a successful result. All signatures need to match a public key. Because public keys are not checked again if they fail any signature comparison, signatures must be placed in the scriptSig using the same order as their corresponding public keys were placed in the scriptPubKey or redeemScript. If all signatures are valid, 1 is returned, 0 otherwise. Due to a bug, one extra unused value is removed from the stack.",
      "OP_CHECKMULTISIGVERIFY": "Same as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.",
      "OP_NOP1": "The word is ignored. Does not mark transaction as invalid.",
      "OP_CHECKLOCKTIMEVERIFY": "<strong>Marks transaction as invalid</strong> if the top stack item is greater than the transaction's nLockTime field, otherwise script evaluation continues as though an OP_NOP was executed. Transaction is also invalid if 1. the stack is empty; or 2. the top stack item is negative; or 3. the top stack item is greater than or equal to 500000000 while the transaction's nLockTime field is less than 500000000, or vice versa; or 4. the input's nSequence field is equal to 0xffffffff. The precise semantics are described in BIP 0065.",
      "OP_NOP2": "OP_CHECKLOCKTIMEVERIFY.",
      "OP_CHECKSEQUENCEVERIFY": "<strong>Marks transaction as invalid</strong> if the relative lock time of the input (enforced by BIP 0068 with nSequence) is not equal to or longer than the value of the top stack item. The precise semantics are described in BIP 0112.",
      "OP_NOP3": "OP_CHECKSEQUENCEVERIFY alias",
      "OP_NOP4": "The word is ignored. Does not mark transaction as invalid.",
      "OP_NOP5": "The word is ignored. Does not mark transaction as invalid.",
      "OP_NOP6": "The word is ignored. Does not mark transaction as invalid.",
      "OP_NOP7": "The word is ignored. Does not mark transaction as invalid.",
      "OP_NOP8": "The word is ignored. Does not mark transaction as invalid.",
      "OP_NOP9": "The word is ignored. Does not mark transaction as invalid.",
      "OP_NOP10": "The word is ignored. Does not mark transaction as invalid.",
      "OP_CHECKSIGADD": "Opcode added by BIP342 (Tapscript)",
      "OP_INVALIDOPCODE": "Invalid code"
    }
  }
}
